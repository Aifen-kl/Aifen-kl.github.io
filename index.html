
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>秃头日记</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="">
    <meta name="description" content="">
    
        <link rel="icon" href="/favicon.ico">
    
    
        
            <link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
        
            <link rel="stylesheet" href="/css/stage.css">
        
            <link rel="stylesheet" href="/css/avatar-bg.css">
        
    
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
<header id="header">
    <div class="menu">
        <i class="fa fa-bars"></i>
    </div>
    <div class="header-main">
        <h1><a href="/">秃头日记</a></h1>
    </div>
    <div id="nav">
        <div class="nav-img" id="nav-img"></div>
        <div class="sentences">
            柿子 开始很涩 过程很苦 结果很甜
        </div>
    </div>
</header>

<div id="content-outer">
    <div id="content-inner">
        <div class="clearfix">
    
    <div id="recent-posts">
        
            <div class="post-item">
                <h1>
                    <a href="/2020/07/09/SSM-MyBatis/">
                        SSM-MyBatis
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-07-09T03:52:08.609Z">
                            2020-07-09
                        </time>
                    
                    
                </div>
                
                    <h1 id="SSM-MyBatis"><a href="#SSM-MyBatis" class="headerlink" title="SSM-MyBatis"></a>SSM-MyBatis</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><img src="/2020/07/09/SSM-MyBatis/image-20200709111443684.png" alt="image-20200709111443684"></p>
<ul>
<li><p>MyBatis前身是iBatis T本是Apache的一个开源的项目</p>
</li>
<li><p><a href="http://mybatis.org" target="_blank" rel="noopener">官方网站</a></p>
</li>
</ul>
<ul>
<li><p>ORM框架</p>
</li>
<li><p>实体类和SQL语句之间建 立映射关系</p>
</li>
<li><p>特点</p>
<ol>
<li>基于SQL语法,简单易学</li>
<li>能了解底层封装过程</li>
<li>SQL语句封装在配置文件中, 便于统一管理与维护,降低程序的耦合度</li>
<li>方便程序代码调试</li>
</ol>
</li>
</ul>
<blockquote>
<p>如何获取mybatis？</p>
</blockquote>
<ul>
<li>GitHub  <a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">地址</a></li>
<li>maven仓库</li>
<li>中文文档 <a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">地址</a></li>
</ul>
<h2 id="2-框架流程"><a href="#2-框架流程" class="headerlink" title="2.框架流程"></a>2.框架流程</h2>
                
                <div class="readmore">
                    <a href="/2020/07/09/SSM-MyBatis/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/07/05/GitHub搭建博客/">
                        GitHub搭建博客
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-07-05T13:01:21.251Z">
                            2020-07-05
                        </time>
                    
                    
                </div>
                
                    <h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h2><ul>
<li><blockquote>
<p><strong>下载软件 node  地址:<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></strong> </p>
</blockquote>
<p>选择自己对应的版本 不同操作系统对应版本不同 一般选择长期稳定版</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705111002447.png" alt="image-20200705111002447"></p>
</li>
<li><blockquote>
<p>注册自己的GitHub账号   搭建自己的线上仓库  网址:<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
</blockquote>
<p>1.注意仓库名 格式 用户名.github.io 例:</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705111233209.png" alt="image-20200705111233209"></p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705125139187.png" alt="image-20200705125139187"></p>
<p>2.新建测试文件 index.jsp 在浏览器打开README.md地址显示就ok了：</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705125835835.png" alt="image-20200705125835835"></p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705125854080.png" alt="image-20200705125854080"></p>
</li>
<li><blockquote>
<p>安装本地Git软件  网址:<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p>
</blockquote>
<p>选择自己对应的版本 不同操作系统对应版本不同</p>
</li>
</ul>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705113722525.png" alt="image-20200705113722525"></p>
<p>2.检测git/node是否安装成功</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705114531590.png" alt="image-20200705114531590"></p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705114623009.png" alt="image-20200705114623009"></p>
<h2 id="2-安装博客框架"><a href="#2-安装博客框架" class="headerlink" title="2.安装博客框架"></a>2.安装博客框架</h2><p>​     2.1.先在本地 创建一个包 放安装脚本和框架（以后的笔记也是这个包）</p>
<blockquote>
<p>2.2.下载[hexo-script]的安装脚本  网址：<a href="https://github.com/kjhuanhao/hexo-script/releases" target="_blank" rel="noopener">https://github.com/kjhuanhao/hexo-script/releases</a></p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705191729301.png" alt="image-20200705191729301"></p>
<p>2.3.将这个脚本保存到之前创建的包，右键打开Git Bash Here ，运行以下命令</p>
<blockquote>
<p>source install.sh test_node            （配置环境变量）</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705192640314.png" alt="image-20200705192640314"></p>
<p>2.4.一键安装hexo博客  ，同样之前创建的包右键打开Git Bash Here ，运行以下命令</p>
<blockquote>
<p>source install.sh hexo_win</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705193128022.png" alt="image-20200705193128022"></p>
<p>2.5.运行查看博客  到生成的文件hexoblog里面右键依次运行以下命令</p>
<blockquote>
<p>cd hexoblog  /    hexo s</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705193331004.png" alt="image-20200705193331004"></p>
<p>2.6.在浏览器打开 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 出现改下页面就下载配置成功了</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705121323176.png" alt="image-20200705121323176"></p>
<p>到这一步，恭喜你，博客已经配置一半了！！！</p>
<h2 id="3-配置公钥"><a href="#3-配置公钥" class="headerlink" title="3.配置公钥"></a>3.配置公钥</h2><p>3.1.一键生成SSH秘钥</p>
<p>——您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p>
<blockquote>
<p>source install.sh git_ssh</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705193802380.png" alt="image-20200705193802380"></p>
<blockquote>
<p>——输入 1</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705193926456.png" alt="image-20200705193926456"></p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705132815535.png" alt="image-20200705132815535"></p>
<p>3.2去C盘查找并复制公钥</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705134208824.png" alt="image-20200705134208824"></p>
<p>3.3将公钥添加到GitHub账号</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705133927399.png" alt="image-20200705133927399"></p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705134004326.png" alt="image-20200705134004326"></p>
<h2 id="4-一键部署"><a href="#4-一键部署" class="headerlink" title="4.一键部署"></a>4.一键部署</h2><p>4.1您需要在存放install.sh脚本的目录中,右键打开git bash运行以下命令:</p>
<blockquote>
<p>source install.sh deploy</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705194141813.png" alt="image-20200705194141813"></p>
<p>4.2你需要将up.sh复制到hexoblog文件,也就是复制到你的博客根目录下</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705194207925.png" alt="image-20200705194207925"></p>
<p>4.3在当前页面右键 gitbash 运行以下命令</p>
<blockquote>
<p>source up.sh</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705194326401.png" alt="image-20200705194326401"></p>
<p>4.4部署博客必要的配置</p>
<blockquote>
<p>首先你需要打开根目录配置文件_config.yml</p>
</blockquote>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705194359025.png" alt="image-20200705194359025"></p>
<p>deploy:<br>  type: git<br>  repo: 这里填你的仓库地址,建议使用SSH地址,它是以git开头的<br>  branch: master</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705135347417.png" alt="image-20200705135347417"></p>
<p>2.修改上面</p>
<p><img src="/2020/07/05/GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20200705135621289.png" alt="image-20200705135621289"></p>
<h2 id="5-提交"><a href="#5-提交" class="headerlink" title="5.提交"></a>5.提交</h2><p>打开生成的hexolog文件夹 右键Git Bash Here 依次输入</p>
<blockquote>
<ol>
<li><p>hexo cl //清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code>。</p>
</li>
<li><p>hexo g  //生成网站静态文件到默认设置的 <code>public</code> 文件夹。</p>
</li>
<li><p>hexo d //自动生成网站静态文件，并部署到设定的仓库。</p>
<p>hexo s  //启动本地服务器，用于预览主题。默认地址:<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
</li>
</ol>
</blockquote>
<p>打开自己的仓库名就能看到自己的线上博客了，大功告成!!!</p>
<p>常见错误解决：hexo d之后出现  ERROR Deployer not found: git  异常</p>
<p>解决：在hexolog文件夹右键 git bash 输入下面指令 （重新部署）</p>
<blockquote>
<p>npm install <code>--</code>save hexo-deployer-git</p>
</blockquote>

                
                <div class="readmore">
                    <a href="/2020/07/05/GitHub搭建博客/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/07/05/MySQL安全管理/">
                        MySQL安全管理
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-07-05T12:12:30.989Z">
                            2020-07-05
                        </time>
                    
                    
                </div>
                
                    <h1 id="MySQL安全管理"><a href="#MySQL安全管理" class="headerlink" title="MySQL安全管理"></a>MySQL安全管理</h1><blockquote>
<p>学习目标：了解MySQL中涉及安全的管理方式、以及各种安全管理的概念和使用方式、使用场景</p>
</blockquote>
<ul>
<li>外键约束</li>
<li>事务管理</li>
<li>预处理</li>
<li>视图</li>
<li>数据备份与还原</li>
<li>用户管理</li>
</ul>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>安全管理</strong>：用各种方式来确保数据库的安全和数据的安全</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>携程的数据库被程序员删库跑路…</p>
<ul>
<li>如果有用户管理，那么可以通过权限限制其没有权限删除</li>
<li>如果有数据备份，即便数据删除，也可以很快的实现数据还原，减小损失</li>
<li>…</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、安全管理是每一个接触数据库的人都应该考虑的问题，尤其是DBA（数据库管理员）</p>
<p>2、数据库安全的维度有很多</p>
<ul>
<li>管理安全：用户、权限、备份还原等</li>
<li>结构安全：外键、视图、事务等</li>
<li>执行层：预处理</li>
</ul>
<h2 id="一、外键约束"><a href="#一、外键约束" class="headerlink" title="一、外键约束"></a>一、外键约束</h2><blockquote>
<p>目标：了解外键的概念和意义，掌握外键约束的管理和实际的应用场景</p>
</blockquote>
<ul>
<li>外键</li>
<li>外键约束</li>
<li>外键管理</li>
</ul>
<h3 id="1、外键"><a href="#1、外键" class="headerlink" title="1、外键"></a>1、外键</h3><blockquote>
<p>目标：认识外键，了解外键的构成条件</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>外键</strong>：foreign key，表中指<strong>向外部表主键</strong>的字段定义成外键</p>
<ul>
<li>外键必须要通过语法指定才能称之为外键<ul>
<li>[constraint<code>外键名</code>] foreign key(当前表字段名) references 外部表(主键字段)</li>
</ul>
</li>
<li>外键构成条件<ul>
<li>外键字段必须与对应表的主键字段类型一致</li>
<li>外键字段本身要求是一个索引（创建外键会自动生成一个索引）</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定表中字段与另外一张表存在关联关系</p>
<p>2、使用外键明确关联外表</p>
<p>3、外键约束成功</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、创建专业表和学生表，学生表中的专业id指向专业表id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">create table t_47(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null unique</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">create table t_48(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    c_id int comment &#39;指向t_46表中的id主键&#39;,</span><br><span class="line">    constraint &#96;c_id&#96; foreign key(c_id) references t_47(id)</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>



<p>2、外键可以不指定名字，系统会自动生成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table t_49(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    c_id int,</span><br><span class="line">    foreign key(c_id) references t_47(id)</span><br><span class="line">)charset utf8;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、外键是需要保证字段与外部连接的主键字段一致的</p>
<p>2、一张表可以有多个外键，但是一个字段只能产生一个外键</p>
<h3 id="2、外键约束"><a href="#2、外键约束" class="headerlink" title="2、外键约束"></a>2、外键约束</h3><blockquote>
<p>目标：了解外键的意义，掌握外键的约束控制和约束作用</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>外键约束</strong>：当表建立外键关系后，外键就会对主表（外键指向的表）和子表（外键所在的表）里的数据产生约束效果</p>
<ul>
<li>外键约束的是写操作（默认操作）<ul>
<li>新增：子表插入的数据对应的外键必须在主表存在</li>
<li>修改：主表的记录如果在子表存在，那么主表的主键不能修改（主键不能修改）</li>
<li>删除：主表的记录如果在子表存在，那么主表的主键不能删除</li>
<li>删除：主表的记录如果在子表存在，那么主表的主键不能删除</li>
</ul>
</li>
<li>外键约束控制：外键可以在定义时控制外键的约束作用<ul>
<li>控制类型<ul>
<li>on update：父表更新时子表的表现</li>
<li>on delete：父表删除时子表的表现</li>
</ul>
</li>
<li>控制方式<ul>
<li>cascade：级联操作，父表操作后子表跟随操作</li>
<li>set null：置空操作，父表操作后，子表关联的外键字段置空</li>
<li>restrict：严格模式，不允许父表操作（默认的）</li>
<li>no action：子表不管</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定表的外键关联关系</p>
<p>2、确定主表的约束控制</p>
<p>3、明确使用相应的约束控制</p>
<p>4、系统自动约束</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、子表不能插入主表不存在的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into t_48 values(null,&#39;Tony&#39;,2);	# 错误</span><br><span class="line"></span><br><span class="line">insert into t_47 values(null,&#39;English&#39;);</span><br><span class="line">insert into t_48 values(null,&#39;Peny&#39;,1);</span><br></pre></td></tr></table></figure>



<p>2、默认的外键产生后，主键不能更新被关联的主键字段或者删除被关联的主键记录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 错误</span><br><span class="line">update t_47 set id &#x3D; 2;</span><br><span class="line">delete from t_47 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>



<p>3、限制外键约束，一般使用更新级联，删除置空</p>
<ul>
<li>on update cascade：更新级联</li>
<li>on delete set null：删除置空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create table t_50(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null unique</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">create table t_51(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    c_id int, # 如果要允许置空，就不能not null</span><br><span class="line">    foreign key(c_id) references t_50(id) on update cascade on delete set null</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t_50 values(null,&#39;Chinese&#39;),(null,&#39;Computer&#39;);</span><br><span class="line">insert into t_51 values(null,&#39;Tony&#39;,1),(null,&#39;Petter&#39;,2);</span><br></pre></td></tr></table></figure>



<ul>
<li>子表依然不允许插入父表不存在的外键</li>
<li>但是可以插入外键为Null的数据</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 错误</span><br><span class="line">insert into t_51 values(null,&#39;Lilei&#39;,3);</span><br><span class="line"></span><br><span class="line">insert into t_51 values(null,&#39;Lilei&#39;,NULL); # OK</span><br></pre></td></tr></table></figure>

<ul>
<li>父表的更新（主键）会让关联的外键自动级联更新</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update t_50 set id &#x3D; 3 where id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<ul>
<li>父表的删除会让关联的外键自动自动置空</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from t_50 where id &#x3D; 3;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、外键约束对子表和父表都有约束</p>
<ul>
<li>子表约束：子表不能插入父表不存在的外键</li>
<li>父表约束<ul>
<li>更新约束（默认不允许）</li>
<li>删除约束（默认不允许）</li>
</ul>
</li>
<li>一般约束<ul>
<li>级联更新</li>
<li>删除置空</li>
</ul>
</li>
</ul>
<p>2、外键约束增强了数据的安全性和可靠性，但是会增加程序对于数据的不可控性，所以是实际开发中一般会通过程序逻辑控制来保证数据的完整性和安全性，外间使用较少</p>
<h3 id="3、外键管理"><a href="#3、外键管理" class="headerlink" title="3、外键管理"></a>3、外键管理</h3><blockquote>
<p>目标：了解外键的维护</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>外键管理</strong>：在表创建后期维护外键</p>
<ul>
<li>新增外键</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add [constraint &#96;外建名&#96;] foreign key(外键字段) references 表名(主键) [on 外键约束]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除外键</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop foreign key 外键名;</span><br></pre></td></tr></table></figure>

<ul>
<li>更新外键：先删除后新增</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、删除外键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_51 drop foreign key t_51_ibfk_1;	# 系统生成的外键</span><br></pre></td></tr></table></figure>



<p>2、追加外键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table t_51 add constraint &#96;t_51_50&#96; foreign key(c_id) references t_50(id);</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：追加外键需要保证外键字段里的值要么为Null，要么在父表中都能找到</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、外键的使用最好的创建表结构的时候就维护好，后期的维护对子表数据有要求</p>
<h2 id="二、事务安全"><a href="#二、事务安全" class="headerlink" title="二、事务安全"></a>二、事务安全</h2><blockquote>
<p>学习目标：了解事务安全的概念和特性，掌握事务安全的应用，能够使用事务安全解决相应问题</p>
</blockquote>
<ul>
<li>事务概念</li>
<li>事务处理</li>
<li>事务特点</li>
</ul>
<h3 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h3><blockquote>
<p>目标：认识事务，了解事务的原理和作用</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>事务</strong>：要做的某个事情</p>
<ul>
<li>计算机中的事务是指某个程序执行单元（写操作）</li>
<li>事务安全：当事务执行后，保障事务的执行是有效的，而不会导致数据错乱</li>
<li>事务安全通常针对的是一连串操作（多个事务）而产生的统一结果</li>
</ul>
<ul>
<li>MySQL中默认的写操作是直接写入的<ul>
<li>执行写操作SQL</li>
<li>同步到数据表</li>
</ul>
</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<p>银行转账：从A账户转账到B账户</p>
<p>创建数据表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table t_52(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    account decimal(10,2) default 0.00</span><br><span class="line">)charset utf8;</span><br><span class="line"></span><br><span class="line">insert into t_52 values(null,&#39;Tom&#39;,10000),(null,&#39;Lucy&#39;,100);</span><br></pre></td></tr></table></figure>



<p>转账：Tom向Lucy转账，一定是分为两步</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Tom扣钱</span><br><span class="line">update t_52 set account &#x3D; account - 1000 where id &#x3D; 1;</span><br><span class="line"></span><br><span class="line"># Lucy收钱</span><br><span class="line">update t_52 set account &#x3D; account + 1000 where id &#x3D; 2;</span><br></pre></td></tr></table></figure>

<ul>
<li>以上两步必须都成功转账才能叫成功</li>
<li>两步操作无法确保哪一步会出问题（尤其是第二步）</li>
<li>为了保障两步都成功才能叫事务安全</li>
</ul>
<blockquote>
<p>事务安全原理</p>
</blockquote>
<p>事务安全是在操作前告知系统，接下来所有的操作都暂<strong>不同步到数据表</strong>，而是记录到<strong>事务日志</strong>，指导后续所有操作都成功，再进行同步；否则取消所有操作</p>
<p>以上述转账为例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(转账开始)--&gt;B[开启事务]</span><br><span class="line">B--&gt;C&#123;事务1:Tom转出1000&#125;</span><br><span class="line">C--&gt;|成功|D[记录到事务日志]</span><br><span class="line">C--&gt;|失败|G</span><br><span class="line">D--&gt;E&#123;事务2:Lucy转入1000&#125;</span><br><span class="line">D--&gt;|失败|G</span><br><span class="line">E--&gt;|成功|F[记录到事务日志]</span><br><span class="line">F--&gt;G[关闭事务&lt;br&gt;成功:提交事务 同步到数据表\清除事务日志&lt;br&gt;失败:回滚事务 清除事务日志]</span><br><span class="line">G--&gt;H((结束))</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、事务的目的就是为了保障连续操作的一致性，保证结果的完整性</p>
<p>2、事务的原理是通过将操作结果暂时保存在事务日志中，等所有操作的结果都是成功的，然后一并同步到数据表</p>
<h3 id="2、事务处理"><a href="#2、事务处理" class="headerlink" title="2、事务处理"></a>2、事务处理</h3><blockquote>
<p>目标：掌握事务的手动实现和自动实现</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>事务处理</strong>：利用自动或者手动方式实现事务管理</p>
<ul>
<li>自动事务处理：系统默认，操作结束直接同步到数据表（事务关闭状态）<ul>
<li>系统控制：变量 autocommit（值为ON，自动提交）</li>
</ul>
</li>
<li>手动事务处理<ul>
<li>开启事务： <code>start transaction</code></li>
<li>关闭事务<ul>
<li>提交事务：<code>commit</code>（同步到数据表同时清空日志数据）</li>
<li>回滚事务：<code>rollback</code>（清空日志数据）</li>
</ul>
</li>
</ul>
</li>
<li>事务回滚：在长事务执行中，可以在某个已经成功的节点处设置回滚点，后续回滚的话可以回到某个成功点<ul>
<li>设置回滚点：<code>savepoint 回滚点名字</code></li>
<li>回滚到回滚点：<code>rollback to 回滚点名字</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定操作需要使用到事务操作</p>
<p>2、开启事务</p>
<p>3、执行事务</p>
<ul>
<li>如果需要回滚点设置：设置回滚点</li>
<li>如果需要回滚：回滚到回滚点</li>
</ul>
<p>4、结束事务</p>
<ul>
<li>成功提交事务：同步到数据表，清空事务日志</li>
<li>失败回滚事务：清空事务日志</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、手动事务：启用事务转账，成功提交事务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line"># Tom扣钱</span><br><span class="line">update t_52 set account &#x3D; account - 1000 where id  &#x3D; 1;</span><br><span class="line"></span><br><span class="line"># Lucy收钱</span><br><span class="line">update t_52 set account &#x3D; account + 1000 where id  &#x3D; 2;</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<p>2、手动事务：启用事务转账，成功提交事务（回滚点）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 开启事务</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line"># Tom扣钱</span><br><span class="line">update t_52 set account &#x3D; account - 1000 where id&#x3D; 1;</span><br><span class="line"></span><br><span class="line"># 设置回滚点</span><br><span class="line">savepoint sp1;</span><br><span class="line"></span><br><span class="line"># Lucy收钱</span><br><span class="line">update t_52 set account &#x3D; account + 10000 where id&#x3D; 2;</span><br><span class="line"></span><br><span class="line"># 操作失败回到回滚点</span><br><span class="line">rollback to sp1;</span><br><span class="line"></span><br><span class="line"># Lucy收钱</span><br><span class="line">update t_52 set account &#x3D; account + 1000 where id&#x3D; 2;</span><br><span class="line"></span><br><span class="line"># 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<p>3、自动事务</p>
<ul>
<li>Mysql默认是自动提交事务的：所以事务一旦发生就会立即写入到数据表（不能多个事务一起完成任务）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;autocommit&#39;;</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭自动提交事务（当前设置级别用户级：当前用户档次连接有效）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set autocommit &#x3D; 0;</span><br></pre></td></tr></table></figure>

<ul>
<li>手动提交事务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into t_52 values(null,&#39;Liu&#39;,1000);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、事务处理要应用到多次写操作组成的大事务中，如金融安全等</p>
<p>2、事务处理通常都会使用手动控制事务，没必要去修改原本的自动提交的机制，开启所有事务</p>
<p>3、扩展：事务处理的支持是有条件的</p>
<ul>
<li>存储引擎需要为InnoDB</li>
</ul>
<h3 id="3、事务特点"><a href="#3、事务特点" class="headerlink" title="3、事务特点"></a>3、事务特点</h3><blockquote>
<p>目标：理解事务的特点</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>事务特点</strong>：事务处理具有ACID四大特性</p>
<ul>
<li>原子性（Atomicity ）：一个事务操作是一个整体，不可拆分，要么都成功，要么都失败</li>
<li>一致性（Consistency）：事务执行之前和执行之后都必须处于一致性状态，数据的完整性没有被破坏（事务逻辑的准确性）</li>
<li>隔离性（Isolation ）：事务操作过程中，其他事务不可见</li>
<li>持久性（Durability ）：事务一旦提交，结果不可改变</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、事务特点需要在对应事务操作时，结合多个用户来看才能看的完整和亲切</p>
<p>2、扩展</p>
<ul>
<li><strong>事务锁</strong>：当一个事务开启时，另外一个事务是不能对当前事务锁占用的数据进行操作的<ul>
<li>行所：当前事务只占用了一行（id精确检索数据），那么其他事务可以操作其他行数据</li>
<li>表所：当前事务占用了整张表（like扫码整个表），那么其他事务对整张表都不能操作</li>
</ul>
</li>
<li><strong>脏读</strong>：一个事务在对某个数据进行操作但尚未提交，而另外一个事务读到了这个“历史”数据其实已经被修改</li>
</ul>
<h2 id="三、预处理"><a href="#三、预处理" class="headerlink" title="三、预处理"></a>三、预处理</h2><blockquote>
<p>学习目标：了解预处理的概念，掌握预处理的使用方式，理解预处理的作用</p>
</blockquote>
<ul>
<li>预处理</li>
<li>预处理传参</li>
</ul>
<h3 id="1、预处理"><a href="#1、预处理" class="headerlink" title="1、预处理"></a>1、预处理</h3><blockquote>
<p>目标：了解预处理的概念，掌握预处理的基本处理方式和应用场景</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>预处理</strong>：prepare statement，一种预先编译SQL指令的方式（然后命令执行）</p>
<ul>
<li>预处理不同于直接处理，是将要执行的SQL指令先发送给服务器编译，然后通过指令执行<ul>
<li>发送预处理：<code>prepare 预处理名字 from &#39;要执行的SQL指令&#39;</code></li>
<li>执行预处理：<code>execute 预处理名字</code></li>
</ul>
</li>
<li>预处理管理<ul>
<li>预处理属于<strong>会话级别</strong>：即当前用户当次连接有效（断开会被服务器清理掉）</li>
<li>删除预处理：<code>deallocate | drop prepare 预处理名字</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、要执行的SQL指令想使用预处理</p>
<ul>
<li>重复执行的指令</li>
<li>涉及数据安全的指令</li>
</ul>
<p>2、发送预处理指令</p>
<p>3、执行预处理</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、查询学生的SQL指令需要重复执行很多次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 普通操作</span><br><span class="line">select * from t_42;</span><br><span class="line"></span><br><span class="line"># 预处理操作：发送预处理</span><br><span class="line">prepare p1 from &#39;select * from t_42&#39;;</span><br><span class="line"></span><br><span class="line"># 预处理操作：执行预处理</span><br><span class="line">execute p1;</span><br><span class="line"></span><br><span class="line"># 删除预处理</span><br><span class="line">deallocate  prepare p1;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>预处理原理</p>
</blockquote>
<p>普通处理和预处理对比</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A(普通处理)--&gt;B[接收SQL指令]</span><br><span class="line">B--&gt;C[编译SQL]</span><br><span class="line">C--&gt;D[执行SQL]</span><br><span class="line">D--&gt;E((返回结果))</span><br><span class="line"></span><br><span class="line">A1(预处理)--&gt;B1[接收预处理指令]</span><br><span class="line">B1--&gt;C1[编译预处理指令]</span><br><span class="line">C1--&gt;D1&#123;是否执行&#125;</span><br><span class="line">D1--&gt;|execute&lt;br&gt;以后都不需要执行接收SQL和编译SQL|E1[执行SQL&lt;br&gt;可重复执行]</span><br><span class="line">D1--&gt;|不执行|F1</span><br><span class="line">E1--&gt;F1((返回结果))</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、预处理就是把要执行的结构（SQL指令）提前发送给服务器端，服务器进行编译但不执行，等待执行指令后才执行</p>
<p>2、预处理的作用</p>
<ul>
<li>性能优化<ul>
<li>效率优化：同样的SQL不用每次都进行编译（编译耗时）<ul>
<li>普通处理：每次都需要编译</li>
<li>预处理：编译一次</li>
</ul>
</li>
<li>网络传输优化：复杂的SQL指令只需要传输一次<ul>
<li>普通处理：每次都需要网络传输SQL指令</li>
<li>预处理：传输一次SQL指令，以后都是执行指令</li>
</ul>
</li>
</ul>
</li>
<li>安全：有效防止SQL注入（外部通过数据的特殊使用使得SQL的执行方式改变）<ul>
<li>普通处理：直接发送给服务器执行（容易出现SQL注入）</li>
<li>预处理：发送的是结构，数据是后期执行传入（传入协议不一样，数据安全性高）</li>
</ul>
</li>
</ul>
<h3 id="2、预处理传参"><a href="#2、预处理传参" class="headerlink" title="2、预处理传参"></a>2、预处理传参</h3><blockquote>
<p>目标：了解预处理的参数处理模式，理解预处理传参的意义</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>预处理传参</strong>：在执行预处理的时候传入<strong>预处理需要的可变数据</strong></p>
<ul>
<li><p>一般预处理都不会是固定死的SQL指令，而是具有一些数据可变的执行（条件）</p>
<ul>
<li>可变数据的位置使用占位符 <code>?</code> 占位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prepare 预处理名字 from &#96;预处理指令 变化部分使用?替代&#96;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行预处理的时候将实际数据传进去代替占位符执行SQL</p>
<ul>
<li>数据存储到变量（预处理传入的值必须是变量保存的）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @变量名 &#x3D; 值</span><br></pre></td></tr></table></figure>

<ul>
<li>使用using关键字传参</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execute 预处理名字 using @变量名</span><br></pre></td></tr></table></figure>

<ul>
<li>数据传入的顺序与预处理中占位符的顺序一致</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、同样的SQL指令要执行N次，但是条件不一致</p>
<p>2、使用预处理占位符发送预处理指令</p>
<p>3、设定变量保存要传入的数据</p>
<p>4、执行预处理，携带变量参数</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>向t_40表中插入数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 准备预处理：涉及参数</span><br><span class="line">prepare t_40_insert from &#39;insert into t_40 values(null,?,?,?,?)&#39;;</span><br><span class="line"></span><br><span class="line"># 设置变量并传入参数</span><br><span class="line">set @name &#x3D; &#39;药师兜&#39;;</span><br><span class="line">set @gender &#x3D; &#39;男&#39;;</span><br><span class="line">set @age &#x3D; 23;</span><br><span class="line">set @class_name &#x3D; &#39;木叶1班&#39;;</span><br><span class="line"></span><br><span class="line"># 执行预处理</span><br><span class="line">execute t_40_insert using @name,@gender,@age,@class_name;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、预处理传参是实际应用预处理时最常见的方式</p>
<p>2、预处理指令可以适用于增删改查各种指令</p>
<p>3、如果预处理的指令不是在一次连接中重复使用，那么预处理反而会降低效率。所以预处理的执行如果不是考虑到安全因素，那么一定是SQL需要重复执行</p>
<h2 id="四、视图"><a href="#四、视图" class="headerlink" title="四、视图"></a>四、视图</h2><blockquote>
<p>学习目标：了解视图的概念，理解视图的作用和应用场景，能够熟练的使用视图来解决相应需求问题</p>
</blockquote>
<ul>
<li>视图概念</li>
<li>视图管理</li>
<li>视图数据操作</li>
<li>视图算法</li>
</ul>
<h3 id="1、视图"><a href="#1、视图" class="headerlink" title="1、视图"></a>1、视图</h3><blockquote>
<p>目标：了解视图的概念，掌握视图的创建和访问</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>视图</strong>：view，一种由select指令组成的<strong>虚拟表</strong></p>
<ul>
<li>视图是虚拟表，可以使用表管理（结构管理）<ul>
<li>为视图提供数据的表叫做基表</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">create view 视图名字 as select指令;</span><br><span class="line"></span><br><span class="line"># 访问视图：一般都是查询</span><br><span class="line">select *&#x2F;字段名 from 视图名字;</span><br></pre></td></tr></table></figure>

<ul>
<li>视图有结构，但不存储数据<ul>
<li>结构：select选择的字段</li>
<li>数据：访问视图时执行的select指令</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定需要使用视图提供数据</p>
<ul>
<li>数据来源是多张表</li>
<li>对外部系统提供数据支撑（保护基表数据）</li>
</ul>
<p>2、使用视图</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、需要对外提供一个学生详情的数据，经常使用：可以利用视图实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 对外提供数据，要保护数据本身的安全</span><br><span class="line"># 需要长期使用</span><br><span class="line"></span><br><span class="line"># 创建视图</span><br><span class="line">create view v_student_info as select * from t_45 left join t_46 using(c_id);</span><br><span class="line"># 使用视图：像表一样使用</span><br><span class="line">select * from v_student_info;</span><br></pre></td></tr></table></figure>



<p>2、有些复杂的SQL又是经常用到的，如多张表的连表操作：可以利用视图实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 院系表</span><br><span class="line">create table t_53(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t_53 values(null,&#39;语言系&#39;),(null,&#39;考古系&#39;);</span><br><span class="line"></span><br><span class="line"># 专业表</span><br><span class="line">create table t_54(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    s_id int not null comment &#39;学院id&#39;</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t_54 values(null,&#39;English&#39;,1),(null,&#39;Chinese&#39;,1);</span><br><span class="line"></span><br><span class="line"># 学生表</span><br><span class="line">create table t_55(</span><br><span class="line">	id int primary key auto_increment,</span><br><span class="line">    name varchar(50) not null,</span><br><span class="line">    s_id int not null comment &#39;专业Id&#39;</span><br><span class="line">)charset utf8;</span><br><span class="line">insert into t_55 values(null,&#39;Lilei&#39;,2),(null,&#39;Mark&#39;,2),(null,&#39;Tony&#39;,1);</span><br><span class="line"></span><br><span class="line"># 获取所有学生的明细信息</span><br><span class="line">select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t_55 as stu left join t_54 sub on stu.s_id &#x3D; sub.id left join t_53 sch on sub.s_id &#x3D; sch.id;</span><br><span class="line"></span><br><span class="line"># 以视图保存这类复杂指令，后续可以直接访问视图</span><br><span class="line">create view v_student_detail as select stu.*,sub.name as sub_name,sub.s_id as sch_id,sch.name as sch_name from t_55 as stu left join t_54 sub on stu.s_id &#x3D; sub.id left join t_53 sch on sub.s_id &#x3D; sch.id;</span><br><span class="line"></span><br><span class="line">select * from v_student_detail;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、视图是用来提供数据支持的，是由select指令组成的结构</p>
<ul>
<li>存在结构</li>
<li>不存在数据（数据是使用时调用select指令动态获取数据）</li>
</ul>
<p>2、视图的目的</p>
<ul>
<li>方便提供全面数据：可以根据需求组织数据，而实际上不会在数据库产生数据冗余</li>
<li>数据安全：视图本质是来源于数据基表，但是对外可以保护基本的数据结构</li>
</ul>
<h3 id="2、视图管理"><a href="#2、视图管理" class="headerlink" title="2、视图管理"></a>2、视图管理</h3><blockquote>
<p>目标：了解视图的结构管理</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>视图管理</strong>：对视图结构的管理</p>
<ul>
<li>视图查看：显示视图结构和具体视图信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables;	# 查看全部视图</span><br><span class="line">show create table&#x2F;view 视图名字;	# 查看视图创建指令</span><br><span class="line">desc 视图名字;	 # 查看视图结构</span><br></pre></td></tr></table></figure>

<ul>
<li>视图修改：更改视图逻辑</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 更改视图</span><br><span class="line">alter view 视图名 as 新的查询指令;</span><br><span class="line">create or replace view 视图名 as 新的查询指令;	# 创建新的或者替换新的</span><br></pre></td></tr></table></figure>

<ul>
<li>视图删除</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure>





<blockquote>
<p>示例</p>
</blockquote>
<p>1、查看全部视图和视图明细</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">show tables;	# 查看全部表，包括视图</span><br><span class="line">desc v_student_detail;	# 查看视图结构</span><br><span class="line">show create view v_student_detail;	# 查看视图创建明细</span><br></pre></td></tr></table></figure>



<p>2、修改视图：重置视图数据逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter view v_student_info as select t1.s_name,t2.c_name from t_45 t1 left join t_46 t2 using(c_id);</span><br><span class="line">create or replace view v_student_info as select t1.s_name,t2.c_name from t_45 t1 left join t_46 t2 using(c_id);</span><br></pre></td></tr></table></figure>



<p>3、删除视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop view v_student_info;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、视图操作与表操作类似，通常情况下不会经常的去修改维护，而是会在一开始就维护好</p>
<p>2、视图管理可以与表一样对结构进行管理</p>
<h3 id="3、视图数据操作"><a href="#3、视图数据操作" class="headerlink" title="3、视图数据操作"></a>3、视图数据操作</h3><blockquote>
<p>目标：了解视图数据操作的概念以及操作原理，掌握视图实现基表数据的操作</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>视图数据操作</strong>：直接对视图进行写操作（增删改）然后实现基表数据的变化</p>
<ul>
<li>视图所有的数据操作都是最终对基表的数据操作</li>
<li>视图操作条件<ul>
<li>多基表视图：不允许操作（增删改都不行）</li>
<li>单基表视图：允许增删改<ul>
<li>新增条件：视图的字段必须包含基表中所有不允许为空的字段</li>
</ul>
</li>
<li>with check option：操作检查规则<ul>
<li>默认不需要这个规则（创建视图时指定）：视图操作只要满足前面上述条件即可</li>
<li>增加此规则：视图的数据操作后，必须要保证该视图还能把通过视图操作的数据查出来（否则失败）</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、根据需求确定需要使用视图</p>
<p>2、确定允许视图进行数据操作（通常用户权限设定，且是单基表视图）</p>
<p>3、确定视图数据的操作是否需要操作检查（有where条件筛选，且只对新增和更新有影响）</p>
<ul>
<li>需要：增加with check option</li>
<li>不需要</li>
</ul>
<p>4、使用视图进行数据操作（最终数据写落点是基表）</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、增加一个单表视图和多表视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view v_student_1 as select s_id,s_name from t_45;</span><br><span class="line">create view v_student_2 as select s.*,c.c_name from t_45 s left join t_46 c using(c_id);</span><br><span class="line">create or replace view v_student_3 as select * from t_45 where c_id is not null with check option;</span><br></pre></td></tr></table></figure>



<p>2、新增数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert into v_student_1 values(null,&#39;student7&#39;);	# 正确：视图包含所有必有字段</span><br><span class="line">insert into v_student_2 values(null,&#39;student8&#39;,null,null); # 错误：不可插入</span><br><span class="line">insert into v_student_3 values(null,&#39;student8&#39;,null);	# 错误：check option，因为第三个字段c_id为NULL，不符合视图筛选条件，查不出来</span><br><span class="line">insert into v_student_3 values(null,&#39;Student9&#39;,1);	# 正确</span><br></pre></td></tr></table></figure>



<p>3、更新数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">update v_student_1 set s_name &#x3D; &#39;boy&#39; where s_id &#x3D; 8;</span><br><span class="line">update v_student_2 set s_name &#x3D; &#39;boy&#39; where s_id &#x3D; 7; # 错误：不可修改</span><br><span class="line">update v_student_3 set c_id &#x3D; null where s_id &#x3D; 1;	  # 错误：check option，修改后c_id为null，变得不符合视图筛选条件了</span><br><span class="line">update v_student_3 set s_name &#x3D; &#39;boy&#39; where s_id &#x3D; 1; # 正确</span><br></pre></td></tr></table></figure>



<p>4、删除数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete from v_student_1 where s_id &#x3D; 2;</span><br><span class="line">delete from v_student_2 where s_id &#x3D; 3;	# 错误：不可删除</span><br><span class="line">delete from v_student_3 where s_id &#x3D; 1;	# 可以删除，说明with check option不影响删除操作</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、视图数据操作一般情况下是不允许的，通常之所以对外提供视图就提供数据的只读操作</p>
<p>2、视图数据操作与视图的基表数量和字段有关</p>
<ul>
<li>多基表视图不允许任何写操作</li>
<li>单基表视图允许更新和删除、根据情况允许新增（视图包含基表中所有不允许为空字段）</li>
</ul>
<p>3、with check option是针对有where条件的视图组成有效，需要手动选择是否增加该选项</p>
<ul>
<li>视图数据的新增、修改后，必须与原来的查询结果是一致的（新增一定要能在视图中看到）</li>
<li>视图数据的删除不受with check option影响</li>
<li>视图数据的新增、修改都是针对当前视图能查出来的，否则既不报错也不生效</li>
<li>with check option还可以更复杂，如果有兴趣可以深入的了解一下</li>
</ul>
<h3 id="4、视图算法"><a href="#4、视图算法" class="headerlink" title="4、视图算法"></a>4、视图算法</h3><blockquote>
<p>目标：了解视图算法的概念和作用，理解各个视图算法的意义</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>视图算法</strong>：指视图在执行过程中对于内部的select指令的处理方式</p>
<ul>
<li>视图算法在创建视图时指定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create ALGORITHM &#x3D; 算法 view 视图名字 as select指令;</span><br></pre></td></tr></table></figure>

<ul>
<li>视图算法一共有三种<ul>
<li>undefined：默认的，未定义算法，即系统自动选择算法</li>
<li>merge：合并算法，就是将视图外部查询语句跟视图内部select语句合并后执行，效率高（系统优先选择）</li>
<li>temptable：临时表算法，即系统将视图的select语句查出来先得出一张临时表，然后外部再查询（temptable算法视图不允许写操作）</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定使用视图</p>
<p>2、确定视图算法：考虑视图内部SQL指令中的子句使用情况</p>
<p>3、创建视图并使用视图</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、创建三种不同算法视图</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create algorithm &#x3D; undefined view v_student_4 as select * from t_42 order by age desc;</span><br><span class="line">create algorithm &#x3D; merge view v_student_5 as select * from t_42 order by age desc;</span><br><span class="line">create algorithm &#x3D; temptable view v_student_6 as select * from t_42 order by age desc;</span><br></pre></td></tr></table></figure>



<p>2、使用视图：为了体现算法效果，给视图增加分组效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(*),any_value(name),any_value(age),class_name,max(age) from v_student_4 group by class_name;</span><br><span class="line">select count(*),any_value(name),any_value(age),class_name,max(age) from v_student_5 group by class_name;</span><br><span class="line">select count(*),any_value(name),any_value(age),class_name,max(age) from v_student_6 group by class_name;</span><br></pre></td></tr></table></figure>



<p>3、临时表算法的视图不能进行数据插入操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into v_student_6 values(null,&#39;冥加&#39;,&#39;男&#39;,100,&#39;神妖1班&#39;); # 错误：不可插入</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、视图算法是用来结合外部外的查询指令的优化思路，主要的优化方式有两种</p>
<ul>
<li>merge：合并算法，将视图的select与外部select合并成一条，然后执行一次（效率高）</li>
<li>temptable：临时表算法，视图的指令单独执行得到一个二维表，然后外部select再执行（安全）</li>
<li>undefined：未定义算法是一种系统自动选择的算法，系统偏向于选择merge算法</li>
</ul>
<p>2、一般在设计视图的时候要考虑到视图算法的可行性，通常视图中如果出现了order by排序的话，就要考虑使用temptable算法</p>
<ul>
<li>只要merge以后，不会导致数据因为子句的先后顺序而混乱（order by与group by的顺序混乱容易出问题）</li>
</ul>
<h2 id="五、数据备份与还原"><a href="#五、数据备份与还原" class="headerlink" title="五、数据备份与还原"></a>五、数据备份与还原</h2><blockquote>
<p>学习目标：了解数据备份与还原的重要性，掌握数据备份与还原的几种方式及其优缺点，能够对不同的数据备份需求提出相应的解决方案</p>
</blockquote>
<ul>
<li><p>单表数据备份与还原</p>
</li>
<li><p>文件备份与还原</p>
</li>
<li><p>SQL备份与还原</p>
</li>
</ul>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>备份</strong>：backup，将数据或者结构按照一定的格式存储到另外一个文件中，以保障阶段数据的完整性和安全性</p>
<ul>
<li>将当前正确数据进行数据保存</li>
<li>备份通常是有固定的时间节点</li>
</ul>
<p><strong>还原</strong>：restore，在当前数据出问题的情况下，将之前备份的数据替换掉当前数据，保证系统的持续、正确的运行</p>
<ul>
<li>基于备份进行数据还原</li>
<li>备份还原不一定能够保证所有损失挽回</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、数据的备份与还原是作为一个正常运行的数据库必须做的事情</p>
<ul>
<li>确保数据的安全</li>
<li>将数据出错的风险降低到最小</li>
</ul>
<p>2、数据库的备份与还原是作为一个DBA最基本的技术要求（开发者也要会）</p>
<h3 id="1、表数据备份"><a href="#1、表数据备份" class="headerlink" title="1、表数据备份"></a>1、表数据备份</h3><blockquote>
<p>目标：了解表数据备份概念，了解表备份数据的应用场景</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>表数据备份</strong>：单独针对表里的<strong>数据部分</strong>进行备份（数据导出）</p>
<ul>
<li>将数据从表中查出，按照一定格式存储到外部文件<ul>
<li>字段格式化：fields<ul>
<li>terminated by：字段数据结束后使用的符号，默认是空格</li>
<li>enclosed by：字段数据包裹，默认什么都没有</li>
<li>escaped by：特殊字符的处理，默认是转义</li>
</ul>
</li>
<li>行格式化：lines<ul>
<li>terminated by：行结束符号，默认是\n，自动换行</li>
<li>starting by：行开始符号，默认没有</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表|*  into outfile 外部文件路径 </span><br><span class="line">	[fields terminated by 格式 enclosed by 格式]</span><br><span class="line">	[lines terminated by 格式 starting by 格式]</span><br><span class="line">from 数据表;</span><br></pre></td></tr></table></figure>

<ul>
<li>表数据备份不限定数据的来源是一张表还是多张表（可以连表）</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定需要对表数据进行导出处理（备份），而且不需要考虑字段名字</p>
<p>2、确定导出的数据的处理</p>
<ul>
<li>字段处理（可以默认）</li>
<li>行处理（可以默认）</li>
</ul>
<p>3、执行表数据导出</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、将t_40表的数据按照默认的方式导出到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * into outfile  &#39;D:&#x2F;t_40.csv&#39; from t_40;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果系统提示：secure-file-priv问题，说明配置没有允许进行文件的导入导出。需要在配置文件里（my.ini）配置好这个配置项：secure-file-priv = 数据导入导出路径/不指定值（重启MySQL生效）</li>
</ul>
<p>2、将t_40表的数据按照指定格式导出到文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select name,gender,age,class_name into outfile &#39;D:&#x2F;t_40_self.csv&#39;</span><br><span class="line">	fields terminated by &#39;-&#39; enclosed by &#39;&quot;&#39;</span><br><span class="line">	lines starting by &#39;GO:&#39;</span><br><span class="line">from t_40;</span><br></pre></td></tr></table></figure>



<p>3、多表数据导出：t_45连接t_46表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * into outfile &#39;D:&#x2F;t_45_46.csv&#39; from t_45 left join t_46 using(c_id);</span><br></pre></td></tr></table></figure>





<blockquote>
<p>小结</p>
</blockquote>
<p>1、表数据备份是一种将表中的数据按照一定的格式导出到外部文件进行保存</p>
<ul>
<li>数据取出后方便进行加工管理</li>
<li>SQL有不同的语法，但是数据的识别是一致的，所以方便进行数据库间的切换</li>
</ul>
<p>2、表数据备份通常是为了进行数据加工后存入回表中，或者到其他表</p>
<p>3、目前比较少用这种方式进行数据备份</p>
<h3 id="2、表数据还原"><a href="#2、表数据还原" class="headerlink" title="2、表数据还原"></a>2、表数据还原</h3><blockquote>
<p>目标：了解表数据还原的概念，了解表数据还原所能解决的问题</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>表数据还原</strong>：将<strong>符合数据表结构</strong>的数据导入到数据表中（数据导入）</p>
<ul>
<li>将一定格式的数据按照一定的解析方式解析成符合表字段格式的数据导入到数据表<ul>
<li>字段处理</li>
<li>行处理</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#39;数据文件所在路径&#39; into table 表名</span><br><span class="line">	[fields terminated by 格式 enclosed by 格式]</span><br><span class="line">	[lines terminated by 格式 starting by 格式]</span><br><span class="line">	[(字段列表)];	# 如果是部分表字段，那么必须将字段列表放到最后</span><br></pre></td></tr></table></figure>

<ul>
<li>数据文件来源<ul>
<li>表数据备份的数据文件</li>
<li>外部获取或者制作的符合格式的数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、数据文件里的数据满足数据表的字段要求</p>
<ul>
<li>数据类型</li>
<li>字段对应数（自增长id、可以为空字段除外）</li>
</ul>
<p>2、数据文件里的数据可以通过字段加工、行加工处理满足表字段要求</p>
<p>3、使用数据导入</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、将t_40.csv数据导入到db_3数据库中的一个与t_40表结构一致的表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t_40 like db_2.t_40;</span><br><span class="line"></span><br><span class="line">load data infile &#39;D:&#x2F;t_40.csv&#39; into table t_40; # 有可能因为字符集出现问题           </span><br><span class="line">load data infile &#39;D:&#x2F;t_40.csv&#39; into table t_40 charset utf8;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：数据加载的时候需要注意外部数据的字符集，在加载的时候需要指定字符集为外部文件数据格式，在表后增加字符集<code>charset 外部文件数据字符集</code></p>
<p>2、将t_40_self文件里的数据导入到db_3.t_40表中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">load data infile &#39;D:&#x2F;t_40_self.csv&#39; into table t_40 charset utf8 fields terminated by &#39;-&#39; enclosed by &#39;&quot;&#39; lines starting by &#39;GO:&#39; (name,gender,age,class_name) ;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、表数据还原其实是将外部符合条件的数据，按照一定的格式要求导入到数据表中</p>
<p>2、数据导入可以解决不同格式数据或者不同数据库产品间的数据互相导入到对应数据库产品的问题</p>
<p>3、目前较少使用这种方式进行数据导入：数据的生成应该是业务产生，而不是人工参与（破坏数据的客观有效性，使得数据不真实）</p>
<h3 id="3、文件备份"><a href="#3、文件备份" class="headerlink" title="3、文件备份"></a>3、文件备份</h3><blockquote>
<p>目标：了解文件备份的概念和原理</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>文件备份</strong>：直接对数据表进行文件保留，属于物理备份</p>
<ul>
<li>文件备份操作简单，直接将数据表（或者数据库文件夹）进行保存迁移</li>
<li>MySQL中不同表存储引擎产生的文件不一致，保存手段也不一致<ul>
<li>InnoDB：表结构文件在ibd文件中，数据和索引存储在外部统一的ibdata文件中(Mysql7以前话是frm后缀)</li>
<li>MyIsam：每张表的数据、结构和索引都是独立文件，直接找到三个文件迁移即可</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、设定备份时间节点</p>
<p>2、设定备份文件存储位置</p>
<p>3、确定备份表的存储引擎</p>
<p>4、根据节点进行文件备份：将文件转移（复制）到其他存储位置</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、MyIsam表的文件备份：找到三个文件，复制迁移</p>
<ul>
<li>sdi：表结构文件</li>
<li>MYI：索引文件</li>
<li>MYD：数据文件</li>
</ul>
<p>2、InnoDB表的文件备份：找到两个文件，复制迁移</p>
<ul>
<li>ibd：表结构文件</li>
<li>ibdata：所有InnoDB数据文件</li>
</ul>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、文件备份是一种简单粗暴的数据备份方式，是直接将数据文件打包管理的方式</p>
<ul>
<li>MyIsam存储引擎相对比较适合文件备份，因为MyIsam存储引擎表文件独立，不关联其他表</li>
<li>InnoDB不适合文件备份，因为不管是备份一张表还是全部数据表，都需要备份整个数据存储文件ibdata（适合整库迁移）</li>
</ul>
<p>2、文件备份方式非常占用磁盘空间</p>
<h3 id="4、文件还原"><a href="#4、文件还原" class="headerlink" title="4、文件还原"></a>4、文件还原</h3><blockquote>
<p>目标：了解文件还原的概念，理解文件还原的方法</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>文件还原</strong>：利用备份的文件，替换出现问题的文件，还原到备份前的良好状态</p>
<ul>
<li><p>直接将备份的文件放到对应的位置即可</p>
</li>
<li><p>文件还原影响</p>
<ul>
<li>MyIsam存储引擎：单表备份，单表还原，不影响其他任何数据</li>
<li>InnoDB存储引擎：单表结构，整库数据，只适合整库备份还原，否则会影响其他InnoDB存储表</li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、找到出问题的数据文件</p>
<ul>
<li>MyIsam：表结构、表数据、表索引三个文件（删掉即可）</li>
<li>InnoDB：表结构、整库数据表ibdata（删掉）</li>
</ul>
<p>2、将备份数据放到相应删除的文件位置</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、MyIsam数据备份表的数据迁移：单表迁移到不同数据库</p>
<p>2、InnoDB数据备份完成整个数据库的迁移（包括数据库用户信息）</p>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、文件备份的还原通常使用较少</p>
<ul>
<li>数据备份占用空间大，这种备份方式就少</li>
<li>InnoDB的备份是针对整个数据库里所有InnoDB表，还原会覆盖掉所有不需要还原的表</li>
</ul>
<p>2、文件备份与还原通常可以在数据迁移的情况下使用</p>
<ul>
<li>MyIsam：独立表的迁移（现在很少用，myisam很少用）</li>
<li>InnoDB：整个数据库的迁移</li>
</ul>
<h3 id="5、SQL备份"><a href="#5、SQL备份" class="headerlink" title="5、SQL备份"></a>5、SQL备份</h3><blockquote>
<p>目标：了解SQL备份的概念，掌握SQL备份的语法和原理</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>SQL备份</strong>：将数据库的数据以SQL指令的形式保存到文件当中，属于逻辑备份</p>
<ul>
<li><p>SQL备份是利用Mysqldump.exe客户端实现备份</p>
</li>
<li><p>SQL备份是将备份目标（数据表）以SQL指令形式，从表的结构、数据和其他信息保存到文件</p>
<p><code>mysqldump.exe -h -P -u -p [备份选项] 数据库名字 [数据表列表] &gt; SQL文件路径</code></p>
</li>
<li><p>备份选项很多，常见的主要是数据库的备份多少</p>
<ul>
<li>全库备份：<code>--all-databases</code> 所有数据库的所有表，也不需要指定数据库名字</li>
<li>单库备份：<code>[--databases] 数据库</code> 指定数据库里的所有表（后面不要给表名）</li>
<li>部分表（单表）备份：<code>数据库名字 表1[ 表2...表N]</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定备份的时间：通常是有规则的时间备份</p>
<p>2、确定备份的目标级别：全库、单库、数据表</p>
<p>3、使用mysqldump实现备份</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、全库备份（借助于Windows下的cmd访问mysqldump.exe，当前用户使用root账号）</p>
<p><code>mysqldump.exe -uroot -proot --all-databases &gt; D:/mysql.sql</code></p>
<p>2、单库备份</p>
<p><code>mysqldump -uroot -proot --databases db_2 &gt; D:/db_2.sql</code></p>
<p>3、单表备份（没有创建数据库的指令）</p>
<p><code>mysqldump -uroot -proot db_2 t_40 t_42 &gt; D:/t_40_42.sql</code></p>
<blockquote>
<p>小结</p>
</blockquote>
<p>1、SQL备份是一般更新频次不高的数据库的常用备份方式</p>
<p>2、SQL备份是将数据表（库）以SQL指令形式进行备份</p>
<ul>
<li>结构指令：表创建（库创建）</li>
<li>数据指令：insert数据</li>
</ul>
<p>3、SQL备份能够完成的备份结构和数据，而结构和数据又是独立的，所以比较方便用作备份和还原</p>
<ul>
<li>SQL备份比较耗费时间和占用性能，建议在闲时进行备份（用户不活跃时）</li>
<li>SQL备份可以根据数据表的重要性进行频次区分备份</li>
</ul>
<h3 id="6、SQL还原"><a href="#6、SQL还原" class="headerlink" title="6、SQL还原"></a>6、SQL还原</h3><blockquote>
<p>目标：了解SQL还原的原理，掌握SQL还原的方式</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>SQL还原</strong>：在需要用到SQL备份数据时，想办法让SQL执行，从而实现备份数据的还原</p>
<ul>
<li>SQL还原可以使用Mysql.exe进行操作</li>
</ul>
<p><code>mysql.exe -h -P -u -p [数据库名字] &lt; SQL文件路径</code></p>
<ul>
<li>SQL还原可以在进入到数据库之后利用SQL指令还原</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source SQL文件路径;</span><br></pre></td></tr></table></figure>

<p><code>备份数据库:mysqldump  -uroot -p 要备份的数据库名&gt; E:\aMySQL\text1.sql</code></p>
<p><code>还原自测 mysql -u root -p 指定存数据的数据库名 &lt; E:\aMySQL\tenement.sql</code></p>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、确定数据库（表）需要进行数据还原</p>
<ul>
<li>数据错乱</li>
<li>数据不完整</li>
</ul>
<p>2、找到对应节点的SQL备份文件</p>
<p>3、SQL还原</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、使用mysql客户端对db_2的数据文件进行单库还原（通常针对数据库）</p>
<p><code>mysql.exe -uroot -p &lt; D:/db_2.sql</code></p>
<ul>
<li>注意：如果不是库备份，那么需要指定数据库才能执行的</li>
</ul>
<p><code>mysql.exe -uroot -p db_2 &lt; D:/t_40_42.sql</code></p>
<p>2、在进入数据库之后，使用source指令还原SQL备份（通常针对表）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source D:&#x2F;t_40_42.sql;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、SQL还原是利用SQL备份文件，触发SQL指令执行，从而恢复到指定时间点的结构和数据</p>
<p>2、SQL还原不能百分百保证数据库的数据不受影响</p>
<ul>
<li>SQL备份通常不具有实时性（一般都会有时间间断）</li>
</ul>
<h3 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h3><p>1、数据的备份与还原是作为数据库管理者和使用者都应该掌握的一项技能</p>
<ul>
<li>保障数据安全</li>
<li>保证系统正常运行</li>
<li>保障公司和客户的利益</li>
</ul>
<p>2、数据库备份与还原的方式很多，每一种都有自己的特点和适用点，需要我们熟练区分和选择</p>
<ul>
<li>表数据备份与还原：适用于数据导出和导入，数据具有结构，但是不包含字段和类型</li>
<li>文件备份与还原：简洁方便，但是需要区分存储引擎InnoDB和MyIsam（InnoDB不适合进行文件备份）</li>
<li>SQL备份与还原：不限定存储引擎，随时随地可以备份，不过备份和还原的效率都比较低（完整备份）</li>
</ul>
<p>3、数据库的备份与还原是一门学问，所以不同的企业、业务都会选择不同的备份策略，也有可能使用交叉策略备份来确保数据的安全，而且一般会将备份文件与运行环境分离开来以确保数据真正的隔离和安全。</p>
<h2 id="六、用户管理"><a href="#六、用户管理" class="headerlink" title="六、用户管理"></a>六、用户管理</h2><blockquote>
<p>学习目标：了解用户管理的目标，掌握用户管理在实际开发过程中的应用</p>
</blockquote>
<ul>
<li>账号管理</li>
<li>权限管理</li>
<li>角色管理</li>
</ul>
<h3 id="1、账号管理"><a href="#1、账号管理" class="headerlink" title="1、账号管理"></a>1、账号管理</h3><blockquote>
<p>目标：了解账号的价值，掌握账号的组成和管理</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>账号管理</strong>：根据项目的需求设置和管理账号</p>
<ul>
<li>账号是权限依赖的对象，先有账号才有权限</li>
<li>MySQL中账号的组成分为两个部分：用户名 @ 主机地址（root@localhost）<ul>
<li>用户名为用户登录时的名字</li>
<li>主机地址：是允许账号所在客户端的访问的客户端IP（如上述root只能在服务器本机通过客户端访问）</li>
</ul>
</li>
<li>账号管理<ul>
<li>创建账号：<code>create user 用户名@主机地址 identified by &#39;明文密码&#39;;</code></li>
<li>删除账号：<code>drop user 用户名@主机地址</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、根据项目要求创建用户</p>
<p>2、根据项目要求删除用户</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、根据项目情况，跟不同的项目组创建不同的账号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># A团队只允许在公司访问服务器，公司IP为163.177.151.110</span><br><span class="line">create user &#96;admin&#96;@&#96;163.177.151.110&#96; identified by &#39;admin123&#39;;</span><br><span class="line"></span><br><span class="line"># B团队不限定负责数据库管理，不限定工作地点</span><br><span class="line">create user &#96;admin&#96; identified by &#39;admin321&#39;;</span><br></pre></td></tr></table></figure>



<p>2、开发任务结束，A团队的任务已经完成，不需要进行数据库操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user &#96;admin&#96;@&#96;163.177.151.110&#96;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、账号管理是用户管理的基础，但是账号管理也只是用户管理的一部分</p>
<ul>
<li>账号管理是要考虑数据安全因素划分</li>
<li>账号管理单独应用较少，一般都要配合权限控制</li>
<li>账号管理也是DBA对于数据库管理的一种重要手段：根据项目划分账号</li>
<li>大的项目或者大的数据库服务器上几乎不会给开发使用root账号（权限太大）</li>
</ul>
<h3 id="2、权限管理"><a href="#2、权限管理" class="headerlink" title="2、权限管理"></a>2、权限管理</h3><blockquote>
<p>目标：了解权限的概念以及与账号的关联关系，掌握对账号的权限赋值和回收权限</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>权限管理</strong>：对账号进行权限的支持与回收</p>
<ul>
<li><p>账号创建之初除了登录是没有其他操作权限的</p>
</li>
<li><p>账号的管理通常需要配合权限的使用</p>
<ul>
<li>赋权：给账号绑定相应的权限 <code>grant 权限列表 on 数据库|*.数据表|* to 用户名@主机地址</code></li>
<li>回收：将账号已有的权限回收 <code>revoke 权限列表 on 数据库|*.数据表|* from 用户名@主机地址</code></li>
<li>刷新权限：<code>flush privileges</code></li>
<li>查看权限：<code>show grants for 用户名@主机地址</code></li>
</ul>
</li>
<li><p>MySQL提供的权限列表</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>Privilege</th>
<th>Grant Table Column</th>
<th>Context</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all" target="_blank" rel="noopener"><code>ALL [PRIVILEGES]</code></a></td>
<td>Synonym for “all privileges”</td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter" target="_blank" rel="noopener"><code>ALTER</code></a></td>
<td><code>Alter_priv</code></td>
<td>Tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine" target="_blank" rel="noopener"><code>ALTER ROUTINE</code></a></td>
<td><code>Alter_routine_priv</code></td>
<td>Stored routines</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create" target="_blank" rel="noopener"><code>CREATE</code></a></td>
<td><code>Create_priv</code></td>
<td>Databases, tables, or indexes</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role" target="_blank" rel="noopener"><code>CREATE ROLE</code></a></td>
<td><code>Create_role_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine" target="_blank" rel="noopener"><code>CREATE ROUTINE</code></a></td>
<td><code>Create_routine_priv</code></td>
<td>Stored routines</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace" target="_blank" rel="noopener"><code>CREATE TABLESPACE</code></a></td>
<td><code>Create_tablespace_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables" target="_blank" rel="noopener"><code>CREATE TEMPORARY TABLES</code></a></td>
<td><code>Create_tmp_table_priv</code></td>
<td>Tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user" target="_blank" rel="noopener"><code>CREATE USER</code></a></td>
<td><code>Create_user_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view" target="_blank" rel="noopener"><code>CREATE VIEW</code></a></td>
<td><code>Create_view_priv</code></td>
<td>Views</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete" target="_blank" rel="noopener"><code>DELETE</code></a></td>
<td><code>Delete_priv</code></td>
<td>Tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop" target="_blank" rel="noopener"><code>DROP</code></a></td>
<td><code>Drop_priv</code></td>
<td>Databases, tables, or views</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role" target="_blank" rel="noopener"><code>DROP ROLE</code></a></td>
<td><code>Drop_role_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event" target="_blank" rel="noopener"><code>EVENT</code></a></td>
<td><code>Event_priv</code></td>
<td>Databases</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute" target="_blank" rel="noopener"><code>EXECUTE</code></a></td>
<td><code>Execute_priv</code></td>
<td>Stored routines</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file" target="_blank" rel="noopener"><code>FILE</code></a></td>
<td><code>File_priv</code></td>
<td>File access on server host</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option" target="_blank" rel="noopener"><code>GRANT OPTION</code></a></td>
<td><code>Grant_priv</code></td>
<td>Databases, tables, or stored routines</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index" target="_blank" rel="noopener"><code>INDEX</code></a></td>
<td><code>Index_priv</code></td>
<td>Tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert" target="_blank" rel="noopener"><code>INSERT</code></a></td>
<td><code>Insert_priv</code></td>
<td>Tables or columns</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables" target="_blank" rel="noopener"><code>LOCK TABLES</code></a></td>
<td><code>Lock_tables_priv</code></td>
<td>Databases</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process" target="_blank" rel="noopener"><code>PROCESS</code></a></td>
<td><code>Process_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy" target="_blank" rel="noopener"><code>PROXY</code></a></td>
<td>See <code>proxies_priv</code> table</td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references" target="_blank" rel="noopener"><code>REFERENCES</code></a></td>
<td><code>References_priv</code></td>
<td>Databases or tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload" target="_blank" rel="noopener"><code>RELOAD</code></a></td>
<td><code>Reload_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client" target="_blank" rel="noopener"><code>REPLICATION CLIENT</code></a></td>
<td><code>Repl_client_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave" target="_blank" rel="noopener"><code>REPLICATION SLAVE</code></a></td>
<td><code>Repl_slave_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select" target="_blank" rel="noopener"><code>SELECT</code></a></td>
<td><code>Select_priv</code></td>
<td>Tables or columns</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases" target="_blank" rel="noopener"><code>SHOW DATABASES</code></a></td>
<td><code>Show_db_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view" target="_blank" rel="noopener"><code>SHOW VIEW</code></a></td>
<td><code>Show_view_priv</code></td>
<td>Views</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown" target="_blank" rel="noopener"><code>SHUTDOWN</code></a></td>
<td><code>Shutdown_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super" target="_blank" rel="noopener"><code>SUPER</code></a></td>
<td><code>Super_priv</code></td>
<td>Server administration</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger" target="_blank" rel="noopener"><code>TRIGGER</code></a></td>
<td><code>Trigger_priv</code></td>
<td>Tables</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update" target="_blank" rel="noopener"><code>UPDATE</code></a></td>
<td><code>Update_priv</code></td>
<td>Tables or columns</td>
</tr>
<tr>
<td><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage" target="_blank" rel="noopener"><code>USAGE</code></a></td>
<td>Synonym for “no privileges”</td>
<td>Server administration</td>
</tr>
</tbody></table>
<blockquote>
<p>步骤</p>
</blockquote>
<p>1、创建新的用户账号</p>
<p>2、根据需求赋予/回收指定数据库（一般整库）或者指定数据表的操作权限</p>
<p>3、刷新权限</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、给用户admin@localhost分配权限：db_2下所有表的所有权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user &#96;admin&#96;@&#96;localhost&#96; identified by &#39;123456&#39;;</span><br><span class="line">grant all privileges on db_2.* to &#96;admin&#96;@&#96;localhost&#96;;</span><br></pre></td></tr></table></figure>



<p>2、给用户admin分配权限：db_2下的查看视图权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">grant select on db_2.v_student_1 to &#96;admin1&#96;;</span><br><span class="line">grant select on db_2.v_student_2 to &#96;admin1&#96;;</span><br><span class="line">grant select on db_2.v_student_3 to &#96;admin1&#96;;</span><br><span class="line">grant select on db_2.v_student_4 to &#96;admin1&#96;;</span><br><span class="line">grant select on db_2.v_student_5 to &#96;admin1&#96;;</span><br><span class="line">grant select on db_2.v_student_6 to &#96;admin1&#96;;</span><br></pre></td></tr></table></figure>



<p>3、回收权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 如果用户不要了，可以直接删除用户，保留用户不给权限，就回收全部权限</span><br><span class="line">revoke all on db_2.* from &#96;admin&#96;@&#96;localhost&#96;;</span><br><span class="line"></span><br><span class="line"># 针对单独授权表的权限回收：只能针对表进行操作</span><br><span class="line">revoke select on db_2.v_student_1 from &#96;admin1&#96;;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、权限管理是整个用户管理的核心：账号只能让用户能够连接服务器，而权限管理才能给用户提供各类操作</p>
<p>2、权限的操作是根据使用账号的用户需要出发的</p>
<ul>
<li>DBA用户通常可以分配整个数据库所有库的权限：all on *.*</li>
<li>项目管理级别的用户可以针对所负责项目的权限：all on 数据库.*（多个项目分配多次）</li>
<li>项目开发者用户可以针对所负责项目模块的权限：权限列表 on 数据库.表名/*（如果是跨项目分配多次）</li>
<li>常用的开发者权限有：<ul>
<li>create、alter、drop：库、表结构操作</li>
<li>insert、select、update、delete：数据操作</li>
<li>references：外键权限</li>
<li>index：索引</li>
</ul>
</li>
</ul>
<p>3、扩展：可以直接使用赋权创建新用户（MySQL7以上不允许这么操作）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant select on db_2.* to &#96;user&#96;@&#96;localhost&#96; with grant option;</span><br></pre></td></tr></table></figure>



<h3 id="3、角色管理"><a href="#3、角色管理" class="headerlink" title="3、角色管理"></a>3、角色管理</h3><blockquote>
<p>目标：了解角色管理的概念，掌握角色管理带来的便捷性</p>
</blockquote>
<blockquote>
<p>概念</p>
</blockquote>
<p><strong>角色管理</strong>：role，即根据角色来分配权限，然后用户只需要关联角色即可（分配角色）：Mysql8以后才有的</p>
<ul>
<li>角色的存在可以更方便的用户维护多个具有相同权限的用户（核心价值）</li>
<li>角色相关操作和语法<ul>
<li>创建角色：<code>create role 角色名字1[,角色名字2,...角色名字N]</code>（可批量创建）</li>
<li>分配权限：<code>grant 权限列表 on 数据库|*.数据表|* to 角色名字</code></li>
<li>绑定角色：<code>grant 角色名字 to 用户名@主机地址</code></li>
<li>撤销角色：<code>revoke 角色名字 from 用户名@主机地址</code></li>
<li>回收角色权限：<code>revoke 权限列表 on 数据库|*.数据表|* from 角色名字</code></li>
<li>删除角色：<code>drop role 角色名字1[,角色名字2,...角色名字N]</code></li>
</ul>
</li>
</ul>
<blockquote>
<p>步骤</p>
</blockquote>
<p><strong>关联角色</strong></p>
<p>1、创建角色</p>
<p>2、确定角色的权限：给角色分配权限</p>
<p>3、将角色分配给用户（和第2步可以没有先后关系）</p>
<p><strong>取关角色</strong></p>
<p>1、权限过大：回收角色权限</p>
<p>2、放弃角色：删除角色</p>
<blockquote>
<p>示例</p>
</blockquote>
<p>1、创建用户角色，分配给具有同样权限的用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建角色（角色与用户名很相似）</span><br><span class="line">create role developer,app_read,app_write;</span><br><span class="line"></span><br><span class="line"># 给角色分配权限</span><br><span class="line">grant all on db_2.* to developer;</span><br><span class="line">grant select on db_2.* to app_read;</span><br><span class="line">grant insert,update,delete on db_2.* to app_write;</span><br><span class="line"></span><br><span class="line"># 创建用户，并分配角色给用户</span><br><span class="line">create user &#39;admin1&#39;@&#39;%&#39; identified by &#39;1234&#39;;</span><br><span class="line">create user &#39;admin2&#39;@&#39;%&#39; identified by &#39;1234&#39;;</span><br><span class="line">create user &#39;admin3&#39;@&#39;%&#39; identified by &#39;1234&#39;;</span><br><span class="line"></span><br><span class="line">grant developer to &#39;admin1&#39;@&#39;%&#39;;</span><br><span class="line">grant app_read to &#39;admin2&#39;@&#39;%&#39;,&#39;admin1&#39;@&#39;%&#39;; # 允许批量给用户分配角色</span><br><span class="line">grant app_write to &#39;admin3&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：虽然权限已经最终关联到用户，但是用户并不能真正使用权限，还需要权限分配者每次登陆服务器时激活角色：<code>set default role all  to 用户名@主机地址</code>（一次只能激活一个角色）</p>
<ul>
<li>激活之后对应的用户需要退出之后重新登录才行</li>
</ul>
<p>2、回收角色权限或者角色</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 回收角色权限</span><br><span class="line">revoke insert,delete on db_2.* from app_write;</span><br><span class="line"></span><br><span class="line"># 回收角色</span><br><span class="line">revoke app_read from &#39;admin2&#39;@&#39;%&#39;;</span><br><span class="line"></span><br><span class="line"># 删除角色</span><br><span class="line">drop role developer;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>小结</p>
</blockquote>
<p>1、角色管理是利用角色与权限关联，实现角色批量关联用户</p>
<ul>
<li>方便权限的重复利用</li>
<li>方便相同权限用户的批量维护</li>
</ul>
<p>2、角色的使用需要角色创建者（有权限的就行）激活角色才能使用（关联角色的用户需要重新登录才会生效）</p>

                
                <div class="readmore">
                    <a href="/2020/07/05/MySQL安全管理/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/07/05/java多线程总结/">
                        java多线程总结
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-07-04T16:13:29.102Z">
                            2020-07-05
                        </time>
                    
                    
                </div>
                
                    <h4 id="线程和进程的区别"><a href="#线程和进程的区别" class="headerlink" title="线程和进程的区别"></a>线程和进程的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程：有独立的内存空间和系统资源。</span><br><span class="line">线程：进程中执行运算的最小单位，可完成一个独立的顺序控制流程。</span><br></pre></td></tr></table></figure>

<h4 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">创建和启动线程：</span><br><span class="line">	创建：①继承Thread类</span><br><span class="line">	      ②实现Runnable接口</span><br><span class="line">    启动：①start();----内置了一个同步</span><br><span class="line">          ②run();</span><br></pre></td></tr></table></figure>

<h4 id="继承Thread和实现Runnable的优势"><a href="#继承Thread和实现Runnable的优势" class="headerlink" title="继承Thread和实现Runnable的优势"></a>继承Thread和实现Runnable的优势</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①：继承Thread类</span><br><span class="line">    编写简单，可直接操作线程</span><br><span class="line">    适用于单继承</span><br><span class="line"></span><br><span class="line">②：实现Runnable接口</span><br><span class="line">    避免单继承局限性</span><br><span class="line">    便于共享资源</span><br></pre></td></tr></table></figure>

<h4 id="线程的状态和调度"><a href="#线程的状态和调度" class="headerlink" title="线程的状态和调度"></a>线程的状态和调度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">A：线程的状态：</span><br><span class="line">	创建、就绪、运行、阻塞、死亡。</span><br><span class="line">B：线程调度：</span><br><span class="line">	①线程的优先级(默认为5)</span><br><span class="line">	    setPriority(int grade)</span><br><span class="line">	    Thread.MIN_PRIORITY</span><br><span class="line">	    Thread.MAX_PRIORITY</span><br><span class="line">	②线程的休眠</span><br><span class="line">	    sleep(long millis)</span><br><span class="line">	③线程的强制运行</span><br><span class="line">	    join()</span><br><span class="line">	    join(long millis)</span><br><span class="line">	    join(long millis,int nanos)</span><br><span class="line">	④线程的礼让(只是提供一种可能，不一定实现)</span><br><span class="line">	    yield()</span><br></pre></td></tr></table></figure>

<h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">同步(synchronized)</span><br><span class="line">	①同步方法：</span><br><span class="line">		例如：访问修饰符 synchronized 返回类型(参数列表) &#123;  &#125;</span><br><span class="line">	②同步代码块：</span><br><span class="line">		例如：synchronized(this) &#123; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">①：线程安全：效率低，适用于多线程。</span><br><span class="line"></span><br><span class="line">②：线程不安全：效率高，适用于单线程。</span><br></pre></td></tr></table></figure>

<h4 id="拓展题目"><a href="#拓展题目" class="headerlink" title="拓展题目"></a>拓展题目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">①：线程创建的三种方式及区别</span><br><span class="line">    https:&#x2F;&#x2F;www.cnblogs.com&#x2F;htyj&#x2F;p&#x2F;10848646.html</span><br><span class="line">②：Java实现线程安全的方式</span><br><span class="line">    https:&#x2F;&#x2F;developer.51cto.com&#x2F;art&#x2F;201910&#x2F;605093.htm</span><br><span class="line">③：JAVA锁有哪些种类，以及区别(没有定力不要看)</span><br><span class="line">    https:&#x2F;&#x2F;www.cnblogs.com&#x2F;lxmyhappy&#x2F;p&#x2F;7380073.html</span><br></pre></td></tr></table></figure>


                
                <div class="readmore">
                    <a href="/2020/07/05/java多线程总结/">
                        阅读更多
                    </a>
                </div>
            </div>
        
            <div class="post-item">
                <h1>
                    <a href="/2020/07/04/Git基础/">
                        Git基础
                    </a>
                </h1>
                <div class="create">
                    <span>创建于</span>
                    
                        <time datetime="2020-07-04T15:06:13.841Z">
                            2020-07-04
                        </time>
                    
                    
                </div>
                
                    <h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<h1 id="Git与svn对比"><a href="#Git与svn对比" class="headerlink" title="Git与svn对比"></a>Git与svn对比</h1><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS)，工作管理系统等。<br>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。<br>Git 与 SVN 区别点：<br>1、Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。<br>2、Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。<br>3、Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。<br>4、Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。<br>5、Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" alt="img"></p>
<h1 id="git工作流程"><a href="#git工作流程" class="headerlink" title="git工作流程"></a>git工作流程</h1><p>一般工作流程如下：</p>
<p>1．从远程仓库中克隆 Git 资源作为本地仓库。</p>
<p>2．从本地仓库中checkout代码然后进行代码修改</p>
<p>3．在提交前先将代码提交到暂存区。</p>
<p>4．提交修改。提交到本地仓库。本地仓库中保存修改的各个历史版本。</p>
<p>5．在修改完成后，需要和团队成员共享代码时，可以将代码push到远程仓库。</p>
<p>下图展示了 Git 的工作流程：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583121531631.png" alt="1583121531631"></p>
<h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。由于开发机大多数情况都是windows，所以本教程只讲解windows下的git的安装及使用。</p>
<h2 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h2><p>下载地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p>
<p>下载安装过程省略…..</p>
<h1 id="使用git管理文件版本"><a href="#使用git管理文件版本" class="headerlink" title="使用git管理文件版本"></a>使用git管理文件版本</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。由于git是分布式版本管理工具，所以git在不需要联网的情况下也具有完整的版本管理能力。</p>
<p>创建一个版本库非常简单，可以使用git bash 也可以使用tortoiseGit 首先，选择一个合适的地方，创建一个空目录(E:\temp\git\repository)</p>
<h2 id="使用GitBash"><a href="#使用GitBash" class="headerlink" title="使用GitBash"></a>使用GitBash</h2><p>在当前目录中点击右键中选择Git Bash来启动。</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583121860348.png" alt="1583121860348"></p>
<p>或者在开始菜单中启动。注意如果是从开始菜单启动的gitbash需要切换目录到仓库所在的目录。</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583122061650.png" alt="1583122061650"></p>
<p>创建仓库执行命令：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$</span> git init</span><br></pre></td></tr></table></figure>



<p>版本库创建成功，会在此目录下创建一个.git的隐藏目录，如下所示：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583122295296.png" alt="1583122295296"></p>
<blockquote>
<p><strong>版本库：“.git**</strong>”目录就是版本库，将来文件都需要保存到版本库中。**</p>
<p><strong>工作目录：包含“.git**</strong>”目录的目录，也就是.git<strong>**目录的上一级目录就是工作目录。只有工作目录中的文件才能保存到版本库中。</strong></p>
</blockquote>
<h2 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h2><p>在E:\temp\git\repository 下创建一个mytest.txt文件</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583122506882.png" alt="1583122506882"></p>
<p>现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。</p>
<p>为此，我们将它们提交到仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;wrote a readme file&quot;</span><br></pre></td></tr></table></figure>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files.&quot;</span><br></pre></td></tr></table></figure>

<p>我们已经成功地添加并提交了一个mytest.txt文件，现在，是时候继续工作了，于是，我们继续修改mytest.txt文件，改成如下内容：</p>
<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\temp\git\repository&gt;git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working direc</span><br><span class="line"></span><br><span class="line">        modified:   mytest.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>mytest.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们<code>mytest.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">E:\temp\git\repository&gt;git diff mytest.txt</span><br><span class="line">diff --git a&#x2F;mytest.txt b&#x2F;mytest.txt</span><br><span class="line">index e69de29..013b5bc 100644</span><br><span class="line">--- a&#x2F;mytest.txt</span><br><span class="line">+++ b&#x2F;mytest.txt</span><br><span class="line">@@ -0,0 +1,2 @@</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line">+Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。知道了对<code>mytest.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add mytest.txt</span><br></pre></td></tr></table></figure>

<p>如果你不使用-m，会出现编辑器来让你写自己的注释信息。</p>
<p>当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m &quot;Changed some files&quot;</span><br></pre></td></tr></table></figure>

<p>git commit 命令的-a选项可将所有<strong>被修改或者已删除的且已经被git管理的文档</strong>提交到仓库中。</p>
<p>千万注意，-a不会造成新文件被提交，只能修改。</p>
<h2 id="发布版本"><a href="#发布版本" class="headerlink" title="发布版本"></a>发布版本</h2><p>我们先从服务器克隆一个库并上传。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git地址</span><br></pre></td></tr></table></figure>

<h2 id="取回更新"><a href="#取回更新" class="headerlink" title="取回更新"></a>取回更新</h2><p>如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>从非默认位置更新到指定的url。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull git地址</span><br></pre></td></tr></table></figure>



<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>现在我们已经在本地创建了一个Git仓库，又想让其他人来协作开发，此时就可以把本地仓库同步到远程仓库，同时还增加了本地仓库的一个备份。</p>
<p>常用的远程仓库就是github：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> 和码云:<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a> 接下来我们演示如何将本地代码同步到码云。</p>
<h3 id="在gitee上创建仓库"><a href="#在gitee上创建仓库" class="headerlink" title="在gitee上创建仓库"></a>在gitee上创建仓库</h3><p>首先你得在gitee上创建一个账号，这个就不演示了。然后在gitee上创建一个仓库：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161210985.png" alt="1583161210985"></p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161259581.png" alt="1583161259581"></p>
<p>Gitee支持两种同步方式“https”和“ssh”。如果使用https很简单基本不需要配置就可以使用，但是每次提交代码和下载代码时都需要输入用户名和密码。如果使用ssh方式就需要客户端先生成一个密钥对，即一个公钥一个私钥。然后还需要把公钥放到githib的服务器上。这两种方式在实际开发中都用应用，所以我们都需要掌握。接下来我们先看ssh方式。</p>
<h2 id="ssh协议"><a href="#ssh协议" class="headerlink" title="ssh协议"></a>ssh协议</h2><h3 id="什么是ssh"><a href="#什么是ssh" class="headerlink" title="什么是ssh?"></a>什么是ssh?</h3><p>SSH 为 Secure Shell（安全外壳协议）的缩写，由 IETF 的网络小组（Network Working Group）所制定。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p>
<h3 id="基于密匙的安全验证"><a href="#基于密匙的安全验证" class="headerlink" title="基于密匙的安全验证"></a>基于密匙的安全验证</h3><p>使用ssh协议通信时，推荐使用基于密钥的验证方式。你必须为自己创建一对密匙，并把公用密匙放在需要访问的服务器上。如果你要连接到SSH服务器上，客户端软件就会向服务器发出请求，请求用你的密匙进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公用密匙，然后把它和你发送过来的公用密匙进行比较。如果两个密匙一致，服务器就用公用密匙加密“质询”（challenge）并把它发送给客户端软件。客户端软件收到“质询”之后就可以用你的私人密匙解密再把它发送给服务器。</p>
<h2 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>克隆远程仓库也就是从远程把仓库复制一份到本地，克隆后会创建一个新的本地仓库。选择一个任意部署仓库的目录，然后克隆远程仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git地址</span><br></pre></td></tr></table></figure>

<p>Git中从远程的分支获取最新的版本到本地有这样2个命令：</p>
<p>git fetch：相当于是从远程获取最新版本到本地，不会自动（合并代码）</p>
<p>git pull：相当于是从远程获取最新版本并merge到本地</p>
<p>上述命令其实相当于git fetch 和 git merge</p>
<p>在实际使用中，git fetch更安全一些</p>
<p>因为在merge前，我们可以查看更新情况，然后再决定是否合并</p>
<h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><h2 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h2><p>在我们每次的提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD指针严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。</p>
<p>一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583161696649.png" alt="1583161696649"></p>
<p>每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。</p>
<p>当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161727676.png" alt="1583161727676"></p>
<p>Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583161760867.png" alt="1583161760867"></p>
<p>假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161794142.png" alt="1583161794142"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161827142.png" alt="1583161827142"></p>
<h1 id="在IntelliJ-IDEA中使用git"><a href="#在IntelliJ-IDEA中使用git" class="headerlink" title="在IntelliJ IDEA中使用git"></a>在IntelliJ IDEA中使用git</h1><h2 id="在Idea中配置git"><a href="#在Idea中配置git" class="headerlink" title="在Idea中配置git"></a>在Idea中配置git</h2><p>安装好IntelliJ IDEA后，如果Git安装在默认路径下，那么idea会自动找到git的位置，如果更改了Git的安装位置则需要手动配置下Git的路径。</p>
<p>选择File→Settings打开设置窗口，找到Version Control下的git选项：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583161885338.png" alt="1583161885338"></p>
<p>选择git的安装目录后可以点击“Test”按钮测试是否正确配置。</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583161911782.png" alt="1583161911782"></p>
<h2 id="将工程添加至git"><a href="#将工程添加至git" class="headerlink" title="将工程添加至git"></a>将工程添加至git</h2><p>1）在idea中创建一个工程，例如创建一个java工程，名称为idea-git-test，如下图所示：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583161936762.png" alt="1583161936762"></p>
<p>2）创建本地仓库</p>
<p>在菜单中选择“vcs”→Import into Version Control→Create Git Repository…</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583161964206.png" alt="1583161964206"></p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5C1583162007512.png" alt="1583162007512"></p>
<p>选择工程所在的上级目录。本例中应该选择idea-projects目录，然后点击“OK”按钮，在工程的上级目录创建本地仓库，那么idea-projects目录就是本地仓库的工作目录，此目录中的工程就可以添加到本地仓库中。也就是可以把idea-git-test工程添加到本地仓库中。</p>
<p>选择之后在工具栏上就多出了git相关工具按钮：</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583162040849.png" alt="1583162040849"></p>
<p>3)将工程添加至本地仓库</p>
<p>直接点击<img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/%5Cclip_image002.jpg" alt="img">commit按钮，将工程提交至本地仓库。</p>
<p>然后点击“commit”按钮，将工程添加至本地仓库。</p>
<p>4）推送到远程</p>
<p>在github上创建一个仓库然后将本地仓库推送到远程。</p>
<p>在工程上点击右键，选择git→Repository→push，</p>
<p>或者在菜单中选择vcs→git→push</p>
<p>点击“push”按钮就讲本地仓库推送到远程，如果是第一次配置推送需要输入github的用户名和密码。</p>
<h2 id="从远程仓库克隆-1"><a href="#从远程仓库克隆-1" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h2><p>关闭工程后，在idea的欢迎页上有“Check out from version control”下拉框，选择git</p>
<p>此处仍然推荐使用htts形式的url，点击“test”按钮后显示连接成功。</p>
<p>点击OK按钮后根据提示将远程仓库克隆下来，然后倒入到idea中。</p>
<h2 id="从服务端拉取代码"><a href="#从服务端拉取代码" class="headerlink" title="从服务端拉取代码"></a>从服务端拉取代码</h2><p>如果需要从服务端同步代码可以使用工具条中的“update”按钮</p>
<p><img src="/2020/07/04/Git%E5%9F%BA%E7%A1%80/1583162276707.png" alt="1583162276707"></p>
<h1 id="客户端软件Sourcetree"><a href="#客户端软件Sourcetree" class="headerlink" title="客户端软件Sourcetree"></a>客户端软件Sourcetree</h1><p>可能对于很多开发来说，只要搞懂git的push、pull、解决一些简单的冲突命令就好了，事实上git的功能十分强大，而通过背命令很难熟记每个逻辑。</p>
<p>当然不同的ide开发环境都有各种各样的git插件，操作方法各不相同，Sourcetree是一个跨平台不受ide限制的git管理工具。不管你做java，还是python、Android都可以使用。</p>
<p>有兴趣的同学可以自行百度学习，在这里不做讲解</p>

                
                <div class="readmore">
                    <a href="/2020/07/04/Git基础/">
                        阅读更多
                    </a>
                </div>
            </div>
        
    </div>


    <div id="content-aside">
    <div class="content-aside-owner">
        <div id="owner">
    <div class="avatar-bg">
        <div class="index-page">
            <div class="banner">
                <div class="slide slide1">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_left">
                            <div id="canvas_left"></div>
                        </div>
                    </div>
                </div>
                <div class="slide slide2">
                    <div class="bg-wrapper">
                        <div class="bg" id="container_right">
                            <div id="canvas_right"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a href="/"><img class="avatar" src="/images/avatar.jpg" alt=""></a>
    <a href="/"><h3 class="author">Aifen-kl</h3></a>
    <h4></h4>
    <div class="social">
        
            
              <a href="https://Aifen-kl.github.io" title="github" class="fa fa-github" target="_blank"></a>
            
        
            
              <a href="#" title="weibo" class="fa fa-weibo" target="_blank"></a>
            
        
    </div>
</div>
    </div>
    
        <div class="content-aside-about">
            <h2>
                <a href="/about">关于</a>
            </h2>
        </div>
    
    <div class="content-aside-tags">
        <h2>
            <a href="/tags">
                标签
                <sup style="font-size: 12px">
                    [0]
                </sup>
            </a>
        </h2>
    </div>
    
<aside id="categories">
    <h2>分类</h2>
    
        <p>None.</p>
    
</aside>

    
<aside id="acchives">
    <h2>归档</h2>
    
    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">七月 2020</a></li></ul>
    
</aside>

</div>

</div>
<nav id="pagination" class="clearfix">
    <span class="page-number current">1</span>
</nav>

    </div>
</div>
<footer id="footer">
    <div id="copyright">&copy; Aifen-kl  2020</div>
    <div id="theme">
        Powered by <a href="http://hexo.io" target="_blank" rel="noopener">Hexo</a>. Theme by <a href="https://github.com/markyong/hexo-theme-stage" target="_blank" rel="noopener">Stage</a>
    </div>
</footer>
<script src="/lib/js/waterrippleeffect.min.js"></script>
<script src="/js/header-bg.main.js"></script>

    <script src="/lib/js/cav.js"></script>
    <script src="/js/avatar-bg.main.js"></script>

</body>
</html>
